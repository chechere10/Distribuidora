generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id           String   @id @default(cuid())
  username     String   @unique
  name         String?  // Nombre para mostrar
  passwordHash String
  role         String   @default("operario") // admin, operario
  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  
  // Relaciones de trazabilidad
  sales              Sale[]
  expenses           Expense[]
  purchases          Purchase[]
  orders             Order[]
  loans              Loan[]
  loanPayments       LoanPayment[]
  inventoryMovements InventoryMovement[]
  cashSessionsOpened CashSession[] @relation("OpenedBy")
  cashSessionsClosed CashSession[] @relation("ClosedBy")
  supplierIssues     SupplierPendingIssue[]
  productReturns     ProductReturn[]
}

model Category {
  id          String    @id @default(cuid())
  name        String    @unique
  description String?
  color       String?   @default("#3B82F6") // Color para UI
  icon        String?   @default("category") // Icono para UI
  isActive    Boolean   @default(true)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  products    Product[]
}

// Cliente especial para precios diferenciados
model PriceList {
  id          String   @id @default(cuid())
  name        String   @unique // Ej: "Público General", "San Alas"
  description String?
  isDefault   Boolean  @default(false)
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  prices      ProductPrice[]
}

// Precios por producto y lista de precios
model ProductPrice {
  id          String    @id @default(cuid())
  productId   String
  priceListId String
  price       Decimal   @db.Decimal(12, 2)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  product   Product   @relation(fields: [productId], references: [id], onDelete: Cascade)
  priceList PriceList @relation(fields: [priceListId], references: [id], onDelete: Cascade)

  @@unique([productId, priceListId])
}

model Product {
  id                   String          @id @default(cuid())
  name                 String
  description          String?
  sku                  String?         @unique
  barcode              String?         @unique
  barcodeImageUrl      String?         // URL de la imagen del código de barras original
  barcodeImageRotation Int             @default(0) // Rotación de la imagen (0, 90, 180, 270)
  barcodeImageScale    Float           @default(1) // Escala de la imagen (0.5 - 3)
  categoryId           String?
  category        Category?       @relation(fields: [categoryId], references: [id])
  defaultPrice    Decimal         @db.Decimal(12, 2) // Precio público por defecto
  priceSanAlas    Decimal?        @db.Decimal(12, 2) // Precio San Alas
  priceEmpleados  Decimal?        @db.Decimal(12, 2) // Precio Empleados
  cost            Decimal         @default(0) @db.Decimal(12, 2)
  imageUrl        String?         // URL de la imagen del producto
  
  // Sistema de unidades con conversión
  baseUnit     String          @default("unidad") // Unidad base: kg, litro, unidad, etc.
  baseStock    Decimal         @default(0) @db.Decimal(12, 3) // Stock en unidad base (ej: 500 kg)
  
  minStock     Int             @default(0) // Stock mínimo para alertas
  isActive     Boolean         @default(true)
  createdAt    DateTime        @default(now())
  updatedAt    DateTime        @updatedAt
  
  // Relaciones
  prices             ProductPrice[]
  presentations      ProductPresentation[] // Diferentes formas de vender (bulto, medio bulto, etc.)
  stockLevels        StockLevel[]
  saleItems          SaleItem[]
  inventoryMovements InventoryMovement[]
  notifications      Notification[]
  purchaseItems      PurchaseItem[]
  orderItems         OrderItem[] // Items de pedidos/fiados
  productReturns     ProductReturn[]
}

// Presentaciones/Etiquetas de un producto (formas de venderlo)
model ProductPresentation {
  id             String   @id @default(cuid())
  productId      String
  name           String   // Ej: "Bulto", "Medio Bulto", "Kilo"
  quantity       Decimal  @db.Decimal(12, 3) // Cantidad en unidad base (ej: 50 para bulto de 50kg)
  price          Decimal  @db.Decimal(12, 2) // Precio de esta presentación (Público)
  priceSanAlas   Decimal? @db.Decimal(12, 2) // Precio San Alas para esta presentación
  priceEmpleados Decimal? @db.Decimal(12, 2) // Precio Empleados para esta presentación
  barcode        String?  @unique // Código de barras específico para esta presentación
  sortOrder      Int      @default(0) // Orden de visualización
  isDefault      Boolean  @default(false) // Si es la presentación por defecto
  isActive       Boolean  @default(true)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  
  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)
  saleItems SaleItem[]
  
  @@unique([productId, name])
}

model Warehouse {
  id          String        @id @default(cuid())
  name        String        @unique
  stockLevels StockLevel[]
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  sales       Sale[]
  orders      Order[]       // Pedidos/Fiados
  inventoryMovements InventoryMovement[]
  notifications      Notification[]
  purchases          Purchase[]
  cashSessions       CashSession[]
  productReturns     ProductReturn[]
}

model StockLevel {
  productId   String
  warehouseId String
  onHand      Decimal  @default(0) @db.Decimal(12, 3) // Stock en unidad base
  minStock    Decimal  @default(0) @db.Decimal(12, 3)

  product   Product   @relation(fields: [productId], references: [id])
  warehouse Warehouse @relation(fields: [warehouseId], references: [id])

  @@id([productId, warehouseId])
}

model InventoryMovement {
  id             String        @id @default(cuid())
  productId      String
  warehouseId    String
  quantity       Decimal       @db.Decimal(12, 3) // Cantidad en unidad base
  type           MovementType
  referenceId    String?
  unitCost       Decimal?      @db.Decimal(12, 2)
  presentationId String?       // Si se vendió por presentación específica
  notes          String?       // Notas del movimiento
  userId         String?       // Usuario que realizó el movimiento
  createdAt      DateTime      @default(now())

  product   Product   @relation(fields: [productId], references: [id])
  warehouse Warehouse @relation(fields: [warehouseId], references: [id])
  user      User?     @relation(fields: [userId], references: [id])
}

enum MovementType {
  IN
  OUT
  ADJUST
}

model Sale {
  id            String     @id @default(cuid())
  saleNumber    Int        @default(autoincrement()) // Consecutivo numérico
  warehouseId   String
  userId        String?    // Usuario que realizó la venta
  total         Decimal    @db.Decimal(12, 2)
  subtotal      Decimal?   @db.Decimal(12, 2) // Subtotal sin domicilio
  domicilio     Decimal?   @db.Decimal(12, 2) // Precio domicilio
  paymentMethod String?    // efectivo, transferencia
  priceType     String     @default("publico") // publico, sanAlas, empleados
  status        String     @default("completed") // completed, returned, cancelled
  cashReceived  Decimal?   @db.Decimal(12, 2)
  change        Decimal?   @db.Decimal(12, 2)
  createdAt     DateTime   @default(now())

  items     SaleItem[]
  warehouse Warehouse @relation(fields: [warehouseId], references: [id])
  user      User?     @relation(fields: [userId], references: [id])
  order     Order?    // Relación inversa con Order
}

model SaleItem {
  id             String   @id @default(cuid())
  saleId         String
  productId      String
  presentationId String?  // Presentación usada (Bulto, Medio Bulto, etc.)
  quantity       Decimal  @db.Decimal(12, 3) // Cantidad vendida
  baseQuantity   Decimal  @db.Decimal(12, 3) // Cantidad en unidad base (para descuento)
  unitPrice      Decimal  @db.Decimal(12, 2)
  subtotal       Decimal  @db.Decimal(12, 2)

  sale         Sale                 @relation(fields: [saleId], references: [id])
  product      Product              @relation(fields: [productId], references: [id])
  presentation ProductPresentation? @relation(fields: [presentationId], references: [id])
}

// Categorías de gastos personalizables
model ExpenseCategory {
  id        String   @id @default(cuid())
  name      String
  icon      String?  @default("receipt")
  color     String   @default("#3B82F6")
  business  String   @default("distribuidora") // distribuidora, sanAlas
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([name, business])
}

model Expense {
  id           String       @id @default(cuid())
  date         DateTime     @default(now())
  business     String       @default("distribuidora") // distribuidora, sanAlas
  category     String       // Categoría del gasto
  subcategory  String?      // Subcategoría opcional
  supplierName String?      // Proveedor o beneficiario
  description  String?      // Descripción detallada
  amount       Decimal      @db.Decimal(12, 2)
  paymentMethod String?     // efectivo, transferencia, credito
  invoiceNumber String?     // Número de factura
  receiptUrl   String?      // URL del comprobante/foto
  isRecurring  Boolean      @default(false) // Si es gasto recurrente
  notes        String?
  userId       String?      // Usuario que registró el gasto
  createdAt    DateTime     @default(now())
  updatedAt    DateTime     @updatedAt
  
  user         User?        @relation(fields: [userId], references: [id])
}

// Trabajadores para préstamos
model Employee {
  id           String   @id @default(cuid())
  name         String
  document     String?  // Cédula
  phone        String?
  position     String?  // Cargo
  salary       Decimal? @db.Decimal(12, 2) // Salario (para calcular cuotas máximas)
  business     String   @default("distribuidora") // distribuidora, sanAlas
  isActive     Boolean  @default(true)
  startDate    DateTime @default(now())
  notes        String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  
  loans        Loan[]   // Préstamos del empleado
}

// Préstamos (a empleados o terceros)
model Loan {
  id             String      @id @default(cuid())
  loanNumber     Int         @default(autoincrement()) // Consecutivo
  type           String      // employee (empleado), third_party (tercero)
  employeeId     String?     // Si es a empleado
  borrowerName   String      // Nombre del prestatario
  borrowerPhone  String?     // Teléfono
  borrowerDocument String?   // Cédula
  business       String      @default("distribuidora") // distribuidora, sanAlas
  
  // Monto y condiciones
  amount         Decimal     @db.Decimal(12, 2) // Monto prestado
  interestRate   Decimal     @default(0) @db.Decimal(5, 2) // Tasa de interés %
  totalAmount    Decimal     @db.Decimal(12, 2) // Monto total a pagar
  paidAmount     Decimal     @default(0) @db.Decimal(12, 2) // Monto ya pagado
  balance        Decimal     @db.Decimal(12, 2) // Saldo pendiente
  
  // Fechas
  disbursementDate DateTime  @default(now()) // Fecha de desembolso
  dueDate        DateTime?   // Fecha límite de pago
  
  // Estado
  status         LoanStatus  @default(ACTIVE)
  notes          String?
  userId         String?     // Usuario que registró el préstamo
  createdAt      DateTime    @default(now())
  updatedAt      DateTime    @updatedAt
  
  employee       Employee?   @relation(fields: [employeeId], references: [id])
  user           User?       @relation(fields: [userId], references: [id])
  payments       LoanPayment[]
}

// Pagos de préstamos
model LoanPayment {
  id            String   @id @default(cuid())
  loanId        String
  amount        Decimal  @db.Decimal(12, 2)
  paymentMethod String?  // efectivo, transferencia, descuento_nomina
  notes         String?
  receiptUrl    String?  // Comprobante
  userId        String?  // Usuario que registró el pago
  createdAt     DateTime @default(now())
  
  loan          Loan     @relation(fields: [loanId], references: [id], onDelete: Cascade)
  user          User?    @relation(fields: [userId], references: [id])
}

enum LoanStatus {
  ACTIVE     // Activo - con saldo pendiente
  PAID       // Pagado completamente
  DEFAULTED  // En mora
  CANCELLED  // Cancelado/Condonado
}

// Proveedores
model Supplier {
  id          String     @id @default(cuid())
  name        String
  contactName String?    // Nombre del contacto
  phone       String?
  email       String?
  address     String?
  nit         String?    // NIT o documento
  notes       String?
  isActive    Boolean    @default(true)
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
  
  purchases   Purchase[]
  pendingIssues SupplierPendingIssue[] // Pendientes con el proveedor
}

// Pendientes/Problemas con proveedores
model SupplierPendingIssue {
  id          String   @id @default(cuid())
  supplierId  String
  purchaseId  String?  // Compra relacionada (opcional)
  type        String   // productos_malos, cambio_pendiente, productos_vencidos, faltante, otro
  description String   // Descripción del pendiente
  amount      Decimal? @db.Decimal(12, 2) // Monto involucrado (si aplica)
  isResolved  Boolean  @default(false)
  resolvedAt  DateTime?
  resolvedNotes String? // Notas de resolución
  userId      String?  // Usuario que registró el pendiente
  resolvedByUserId String? // Usuario que resolvió
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  supplier    Supplier @relation(fields: [supplierId], references: [id], onDelete: Cascade)
  user        User?    @relation(fields: [userId], references: [id])
}

model Purchase {
  id           String     @id @default(cuid())
  purchaseNumber Int      @default(autoincrement()) // Consecutivo
  date         DateTime   @default(now())
  supplierId   String?
  supplierName String?    // Backup del nombre
  warehouseId  String
  subtotal     Decimal    @db.Decimal(12, 2)
  tax          Decimal?   @db.Decimal(12, 2)
  discount     Decimal?   @db.Decimal(12, 2)
  total        Decimal    @db.Decimal(12, 2)
  status       PurchaseStatus @default(RECEIVED)
  invoiceNumber String?   // Número de factura del proveedor
  notes        String?
  userId       String?    // Usuario que registró la compra
  createdAt    DateTime   @default(now())

  supplier  Supplier?  @relation(fields: [supplierId], references: [id])
  user      User?      @relation(fields: [userId], references: [id])
  items     PurchaseItem[]
  warehouse Warehouse @relation(fields: [warehouseId], references: [id])
}

enum PurchaseStatus {
  PENDING   // Pedido pendiente de recibir
  RECEIVED  // Recibido y en inventario
  CANCELLED // Cancelado
}

model PurchaseItem {
  id              String  @id @default(cuid())
  purchaseId      String
  productId       String
  productName     String  // Backup del nombre del producto
  presentationId  String? // Si se compró por presentación
  presentationName String? // Backup del nombre
  quantity        Decimal @db.Decimal(12, 3) // Cantidad comprada
  baseQuantity    Decimal @db.Decimal(12, 3) // Cantidad en unidad base (para stock)
  unitCost        Decimal @db.Decimal(12, 2)
  subtotal        Decimal @db.Decimal(12, 2)

  purchase Purchase @relation(fields: [purchaseId], references: [id], onDelete: Cascade)
  product  Product  @relation(fields: [productId], references: [id])
}

model Notification {
  id          String    @id @default(cuid())
  type        String
  message     String
  productId   String?
  warehouseId String?
  createdAt   DateTime  @default(now())
  resolvedAt  DateTime?

  product   Product?   @relation(fields: [productId], references: [id])
  warehouse Warehouse? @relation(fields: [warehouseId], references: [id])
}

model CashSession {
  id             String   @id @default(cuid())
  warehouseId    String
  openedAt       DateTime @default(now())
  closedAt       DateTime?
  openingAmount  Decimal  @default(0) @db.Decimal(12, 2)
  closingAmount  Decimal? @db.Decimal(12, 2)
  openedByUserId String?  // Usuario que abrió la caja
  closedByUserId String?  // Usuario que cerró la caja
  
  // Resumen del cierre
  totalSales       Decimal? @db.Decimal(12, 2) // Total ventas del periodo
  totalCash        Decimal? @db.Decimal(12, 2) // Total en efectivo
  totalTransfer    Decimal? @db.Decimal(12, 2) // Total transferencias
  totalFiados      Decimal? @db.Decimal(12, 2) // Total fiados generados
  salesCount       Int?     // Cantidad de ventas
  expectedCash     Decimal? @db.Decimal(12, 2) // Efectivo esperado
  cashDifference   Decimal? @db.Decimal(12, 2) // Diferencia (faltante/sobrante)
  notes            String?  // Notas del cierre

  warehouse Warehouse   @relation(fields: [warehouseId], references: [id])
  openedBy  User?       @relation("OpenedBy", fields: [openedByUserId], references: [id])
  closedBy  User?       @relation("ClosedBy", fields: [closedByUserId], references: [id])
  movements CashMovement[]

  @@index([warehouseId, closedAt])
}

model CashMovement {
  id            String   @id @default(cuid())
  sessionId     String
  type          CashMovementType
  amount        Decimal  @db.Decimal(12, 2)
  referenceType String?
  referenceId   String?
  notes         String?
  createdAt     DateTime @default(now())

  session CashSession @relation(fields: [sessionId], references: [id])
}

enum CashMovementType {
  IN
  OUT
}

// Pedidos/Fiados - Ventas pendientes de pago
model Order {
  id            String      @id @default(cuid())
  warehouseId   String
  userId        String?     // Usuario que registró el fiado
  customerName  String?     // Nombre del cliente que fía
  customerPhone String?     // Teléfono para contactar
  total         Decimal     @db.Decimal(12, 2)
  priceType     String      @default("publico") // publico, sanAlas, empleados
  status        OrderStatus @default(PENDING)
  notes         String?     // Notas adicionales
  dueDate       DateTime?   // Fecha compromiso de pago
  createdAt     DateTime    @default(now())  // Fecha del pedido
  paidAt        DateTime?   // Fecha en que pagó (cuando se marca como pagado)
  paidByUserId  String?     // Usuario que registró el pago
  paymentMethod String?     // efectivo o transferencia (cuando paga)
  saleId        String?     @unique // Referencia a la venta creada cuando paga

  items     OrderItem[]
  warehouse Warehouse   @relation(fields: [warehouseId], references: [id])
  user      User?       @relation(fields: [userId], references: [id])
  sale      Sale?       @relation(fields: [saleId], references: [id])
}

model OrderItem {
  id             String   @id @default(cuid())
  orderId        String
  productId      String
  productName    String   // Guardar nombre por si el producto se elimina
  presentationId String?
  presentationName String? // Guardar nombre de presentación
  quantity       Decimal  @db.Decimal(12, 3)
  baseQuantity   Decimal  @db.Decimal(12, 3) // Cantidad en unidad base
  unitPrice      Decimal  @db.Decimal(12, 2)
  subtotal       Decimal  @db.Decimal(12, 2)

  order   Order   @relation(fields: [orderId], references: [id], onDelete: Cascade)
  product Product @relation(fields: [productId], references: [id])
}

enum OrderStatus {
  PENDING   // Pendiente de pago
  PAID      // Pagado
  CANCELLED // Cancelado
  RETURNED  // Devuelto (pagó pero luego devolvió)
}

// Devoluciones de productos
model ProductReturn {
  id            String   @id @default(cuid())
  returnNumber  Int      @default(autoincrement()) // Consecutivo
  warehouseId   String
  saleId        String?  // Venta original (opcional)
  productId     String
  presentationId String? // Presentación devuelta (opcional)
  quantity      Decimal  @db.Decimal(12, 3) // Cantidad devuelta
  baseQuantity  Decimal  @db.Decimal(12, 3) // Cantidad en unidad base (para stock)
  unitPrice     Decimal  @db.Decimal(12, 2) // Precio unitario a devolver
  total         Decimal  @db.Decimal(12, 2) // Total a devolver
  reason        String   // Motivo de la devolución
  notes         String?  // Notas adicionales
  userId        String?  // Usuario que registró
  createdAt     DateTime @default(now())

  warehouse Warehouse @relation(fields: [warehouseId], references: [id])
  product   Product   @relation(fields: [productId], references: [id])
  user      User?     @relation(fields: [userId], references: [id])
}


